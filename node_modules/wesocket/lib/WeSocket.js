'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _stompjs = require('stompjs');

var _stompjs2 = _interopRequireDefault(_stompjs);

var _sockjsClient = require('sockjs-client');

var _sockjsClient2 = _interopRequireDefault(_sockjsClient);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var RETRY_COUNT = 0;

var WeSocket = function () {
    function WeSocket(url, _ref) {
        var name = _ref.name,
            _ref$group = _ref.group,
            group = _ref$group === undefined ? 'default' : _ref$group,
            _ref$role = _ref.role,
            role = _ref$role === undefined ? 'default' : _ref$role;

        _classCallCheck(this, WeSocket);

        if (typeof arguments[1] === 'string') {
            name = arguments[1];
        }
        this.user = { name: name, group: group, role: role };
        this.url = url + '?user=' + name + '&group=' + group + '&role=' + role;
        this.kickOut = false;
        this.events = {
            connected: function connected() {}, close: function close() {}, broadcast: function broadcast() {}, error: function error() {}, notice: function notice() {}, group: function group() {}, role: function role() {}
        };

        Object.defineProperties(this, {
            url: { enumerable: false, configurable: false, writable: false },
            user: { enumerable: false, configurable: false, writable: false },
            events: { enumerable: false, configurable: false, writable: false }
        });
    }

    _createClass(WeSocket, [{
        key: 'on',
        value: function on(event, handler) {
            var _this = this;

            if (Array.isArray(event)) {
                event.forEach(function (evt) {
                    return _this.on(evt, handler);
                });
                return this;
            }
            if (typeof handler !== 'function') {
                throw new Error('handler not a function');
            } else if (event in this.events) {
                this.events[event] = handler;
            } else {
                throw new Error('Unsupport event');
            }
            return this;
        }

        /**
         * @param options
         *  eg: {ready, reconnect={retry: false, count: 10, interval: 10}, debug}
         *  reconnect 重连参数 retry: 已经尝试次数 count：重试次数 interval：重连间隔
         */

    }, {
        key: 'connect',
        value: function connect(options) {
            var _this2 = this;

            this.client = _stompjs2.default.over(new _sockjsClient2.default(this.url));
            if (options) {
                var _options$reconnect = options.reconnect,
                    reconnect = _options$reconnect === undefined ? {} : _options$reconnect;

                var defs = { debug: options.debug !== false };
                defs.reconnect = options.reconnect ? { retry: reconnect.retry || 10, interval: reconnect.interval || 10 } : false;
                defs.ready = options.ready || function () {};
                this.options = defs;
            }
            if (!this.options) throw new Error('Options lost');
            var ready = this.options.ready;

            if (!this.options.debug) this.client.debug = false;
            var client = this.client,
                user = this.user,
                _events = this.events,
                connected = _events.connected,
                broadcast = _events.broadcast,
                notice = _events.notice,
                group = _events.group,
                role = _events.role;

            var receives = {};
            var parse = function parse(e) {
                var body = e.body;
                try {
                    body = JSON.parse(body);
                } catch (e) {}
                var _body = body,
                    event = _body.event,
                    message = _body.message,
                    id = _body.id,
                    timestamp = _body.timestamp;

                if (event === 'KICK_OUT') {
                    _this2.kickOut = true;
                    return;
                }
                if (receives[id]) return;
                receives[id] = true;
                try {
                    message = JSON.parse(message);
                } catch (e) {}
                return [event, message, id, timestamp];
            };
            var subscribes = {
                broadcast: ["/broadcast", broadcast],
                notice: ['/user/notice', notice],
                group: ['/broadcast/' + user.group, group],
                role: ['/broadcast/' + user.group + '_' + user.role, role]
            };
            client.connect(user, function (frame) {
                RETRY_COUNT = 0;
                _this2.options.debug && console.debug('Connect success link:\u3010' + _this2.url + '\u3011');
                ready && ready.call(_this2);
                connected.call(_this2, frame);

                var _loop = function _loop(evt) {
                    var _subscribes$evt = _slicedToArray(subscribes[evt], 2),
                        path = _subscribes$evt[0],
                        handler = _subscribes$evt[1];

                    _this2.options.debug && console.debug('Subscribe at \u3010' + path + '\u3011');
                    client.subscribe(path, function (e) {
                        var args = parse(e);
                        if (args) handler.apply(e, args);
                    });
                };

                for (var evt in subscribes) {
                    _loop(evt);
                }
            }, function (error) {
                // 如果需要重连 且重试次数小于retry 且为非强制下线
                var reconnect = _this2.options.reconnect;

                if (!_this2.kickOut && reconnect && reconnect.retry > RETRY_COUNT) {
                    RETRY_COUNT++;
                    var interval = reconnect.interval || 10;
                    // interval 秒之后自动重连
                    _this2.options.debug && console.debug('Retry after ' + interval + 's, retry count ' + RETRY_COUNT);
                    setTimeout(_this2.reconnect.bind(_this2), interval * 1000);
                }
                if (error.indexOf('Lost connection') !== -1) {
                    _this2.events.close.call(_this2);
                } else {
                    _this2.events.error.call(_this2, error);
                }
            });
        }
    }, {
        key: 'reconnect',
        value: function reconnect() {
            this.connect();
        }
    }, {
        key: 'send',
        value: function send(message, event) {
            this.client.send("/message", {}, JSON.stringify({ message: message, event: event }));
        }
    }, {
        key: 'disconnect',
        value: function disconnect() {
            this.client.disconnect();
        }
    }]);

    return WeSocket;
}();

exports.default = WeSocket;